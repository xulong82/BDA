(y <- y + rnorm(length(y), 0, 1))
set.seed(1)
(y <- y + rnorm(length(y), 0, 1))
set.seed(1)
(y <- y + rnorm(length(y), 0, 1))
set.seed(1)
y = as.numeric(sample) * 3
(y <- y + rnorm(length(y), 0, 1))
set.seed(1)
y = as.numeric(sample) * 3
(y <- y + rnorm(length(y), 0, 1))
lm(y ~ sample)
lm(y ~ sample) %>% summary
library(dplyr)
sample <- rep(group, each = 3) %>% as.factor
set.seed(1)
(y <- as.numeric(sample) * 3)
(y <- y + rnorm(length(y), 0, 1))
lm(y ~ sample) %>% summary
7.0267 / 0.6265
sample
y2 <- y1[1:6]
y1 = y
y2 <- y1[1:6]
sample2 <- sample[1:6]
lm(y2 ~ sample2) %>% summary
f <- formula ( ~ sample )
f
design.matrix(f)
model.matrix(f)
f1 <- formula ( ~ sample )
m1 <- model.matrix(f1)
x = rep(c("A", "B", "C"), each = 3) %>% as.factor
(x <- rep(c("A", "B", "C"), each = 3) %>% as.factor)
m1 <- model.matrix( ~ x)
m1
(x <- rep(c("A", "B", "C"), each = 3) %>% as.factor)
set.seed(1)
(y <- as.numeric(x) * 3)
(y <- y + rnorm(length(y), 0, 1))
lm(y ~ x) %>% summary
(fit = lm(y ~ x) %>% summary)
X <- model.matrix( ~ x)
crossprod(X)X
(X <- model.matrix( ~ x))
crossprod(X)
crossprod(X) %*% crossprod(X, y)
solve(crossprod(X)) %*% crossprod(X, y)
fit
(beta = solve(crossprod(X)) %*% crossprod(X, y))
X
X %*% beta
y - X %*% beta
(res = y - X %*% beta)
fit$residuals
var(res)
var(res)
solve(crossprod(X))
var(res)
var(res) %*% solve(crossprod(X))
var(res) * solve(crossprod(X))
solve(crossprod(X))
diag(var(res)) * solve(crossprod(X))
var(res) * diag(solve(crossprod(X)))
var(res) * diag(solve(crossprod(X)))
summary(fit)
(fit = lm(y ~ x) %>% summary)
var = var(res) * diag(solve(crossprod(X)))
sqrt(var)
N = 9
p = 3
var(res) * N / (N - p)
var_res = var(res) * N / (N - p)
var_beta = var_res * diag(solve(crossprod(X)))
se_beta = sqrt(var_beta)
(se_beta = sqrt(var_beta))
var_res = var(res) * (N - 1) / (N - p)
var_beta = var_res * diag(solve(crossprod(X)))
(se_beta = sqrt(var_beta))
fit
diag(solve(crossprod(X)))
x2 <- x[1:6]
(X2 <- model.matrix( ~ x2))
diag(solve(crossprod(X)))
diag(solve(crossprod(X2)))
X2
x2
(X2 <- model.matrix( ~ x2))
X2
x2 <- as.factor(x[1:6])
x2
(x2 <- rep(c("A", "B"), each = 3) %>% as.factor)
(X2 <- model.matrix( ~ x2))
diag(solve(crossprod(X)))
diag(solve(crossprod(X2)))
(fit2 = lm(y2 ~ x2) %>% summary)
(res = y - X %*% beta)
fit2$residuals
var_res2 = var(fit2$residuals) * (N - 1) / (N - p) # Correct
var_res2 = var(fit2$residuals) * (N - 1) / (N - p) # Correct
N = 9
p = 3
(var_res = var(res) * (N - 1) / (N - p)) # Correct
N = 6
p = 2
(var_res2 = var(fit2$residuals) * (N - 1) / (N - p)) # Correct
str(fit)
fit$sigma
sqrt(fit$sigma)
fit$sigma^2
(var_res = var(res) * (N - 1) / (N - p)) # Correct
N = 9
p = 3
(var_res = var(res) * (N - 1) / (N - p)) # Correct
fit$sigma^2
y
y[7:9] <- y[7:9] + rnorm(3, 0, 10)
(fit = lm(y ~ x) %>% summary)
fit$sigma^2
fit2
(x <- rep(c("A", "B", "C"), each = 3) %>% as.factor)
set.seed(1)
(y <- as.numeric(x) * 3)
(y <- y + rnorm(length(y), 0, 1))
(fit = lm(y ~ x) %>% summary)
y[7:9] <- y[7:9] + rnorm(3, 0, 10)
(fit2 = lm(y ~ x) %>% summary)
(fit2 = lm(y2 ~ x2) %>% summary)
(fit = lm(y ~ x) %>% summary)
fit
fit2
solve(crossprod(x))
x
solve(crossprod(X))
solve(crossprod(X2))
(res = y - X %*% beta)
(res2 = y2 - X2 %*% beta2)
(beta2 = solve(crossprod(X1)) %*% crossprod(X1, y2))
(beta2 = solve(crossprod(X2)) %*% crossprod(X2, y2))
(res2 = y2 - X2 %*% beta2)
(res = y - X %*% beta)
N = 9
p = 3
(var_res = var(res) * (N - 1) / (N - p))
fit$sigma^2
N2 = 6
p2 = 2
(var_res = var(fit$residuals) * (N - 1) / (N - p))
(res = y - X %*% beta)
(var_res = var(res) * (N - 1) / (N - p))
fit$residuals
res
set.seed(1)
(y <- as.numeric(x) * 3)
(y <- y + rnorm(length(y), 0, 1))
(fit = lm(y ~ x) %>% summary)
(res = y - X %*% beta)
(res2 = y2 - X2 %*% beta2)
(var_res = var(fit$residuals) * (N - 1) / (N - p))
(var_res = var(res) * (N - 1) / (N - p))
fit$sigma^2
var_beta = var_res * diag(solve(crossprod(X)))
(se_beta = sqrt(var_beta))
var_beta2 = var_res2 * diag(solve(crossprod(X2)))
(se_beta2 = sqrt(var_beta2))
fit$coefficients
fit_new <- lm(y ~ x)
fit_new <- lm(y ~ x) %>% summary
(fit_new <- lm(y ~ x) %>% summary)
fit2
y
y[7:9] <- y[7:9] + rnorm(3, 0, 10)
(fit_new <- lm(y ~ x) %>% summary)
fit2
fit2$coefficients[, "Std. Error"]
fit_new$coefficients[, "Std. Error"]
rm(list = ls())
library(MASS)
library(rstan)
stan_multi_norm <- "
data {
int<lower=1> K; # outcomes
vector[K] mu;
cov_matrix[K] Sigma;
}
parameters {
vector[K] beta;
}
model {
beta ~ multi_normal(mu, Sigma);
}
"
stan_multi_cholesky <- "
data {
int<lower=1> K; # outcomes
vector[K] mu;
cov_matrix[K] Sigma;
}
transformed data {
matrix[K, K] L;
L <- cholesky_decompose(Sigma);
}
parameters {
vector[K] beta;
}
model {
beta ~ multi_normal_cholesky(mu, L);
}
"
stan_cholesky <- "
data {
int<lower=1> K; # outcomes
vector[K] mu;
cov_matrix[K] Sigma;
}
transformed data {
matrix[K, K] L;
L <- cholesky_decompose(Sigma);
}
parameters {
vector[K] alpha;
}
transformed parameters {
vector[K] beta;
beta <- mu + L * alpha;
}
model {
alpha ~ normal(0, 1);
}
"
stan_multi_norm <- stan_model(model_code = stan_multi_norm)
stan_multi_cholesky <- stan_model(model_code = stan_multi_cholesky)
stan_cholesky <- stan_model(model_code = stan_cholesky)
(Sigma <- matrix(c(10, 3, 3, 2), 2, 2))
y = mvrnorm(n = 1e3, mu = rep(0, 2), Sigma)
head(y)
colMeans(y)
var(y)
dat <- list(K = 2, mu = c(0, 0), Sigma = Sigma) # pseudo-data
(fit_multi_norm <- sampling(stan_multi_norm, data = dat)) #
load("~/Dropbox/GitHub/Adsp/data/mdata.rdt")
load("~/Dropbox/GitHub/Adsp/data/kinship.rdt")
Sigma <- kinship$autosome
Sigma[Sigma < 0] <- 0
dat <- list(K = 576, mu = rep(0, 576), Sigma = Sigma) # pseudo-data
(fit_multi_norm <- sampling(stan_multi_norm, data = dat)) # 540 sec each chain
(fit_multi_norm <- sampling(stan_multi_norm, chain = 2, data = dat)) # 540 sec each chain
fit = fit_multi_norm
x = summary(fit)$summary[, "mean"]
samples = extract(fit) # samples
str(samples)
b = var(samples$beta)
b
cor(Sigma[1, ], b[1, ])
str(b)
b[1:10, 1:10]
col(samples$beta[, 1], samples$beta[, 2])
samples$beta[, 1]
samples$beta[, 2]
cor(samples$beta[, 1], samples$beta[, 2])
cor(c(1, 0, 0), c(0, 2, 0))
Sigma[1:10, 1:10]
b[1:10, 1:10]
(fit_multi_cholesky <- sampling(stan_multi_cholesky, data = dat)) # 195 sec each chain
(fit_cholesky <- sampling(stan_cholesky, chain = 2, data = dat)) # 135 sec each chain, 4X speed
fit = fit_cholesky
samples = extract(fit) # samples
beta = var(samples$beta)
image(beta)
alpha = var(samples$alpha)
beta = var(samples$beta)
image(Sigma)
cor(Sigma[1, ], beta[1, ])
alpha
alpha[1:10, 1:10]
stan_cholesky <- "
data {
int<lower=1> K; # outcomes
cov_matrix[K] Sigma;
vector[K] y;
}
transformed data {
matrix[K, K] L;
L <- cholesky_decompose(Sigma);
}
parameters {
real mu;
vector[K] alpha;
real<lower=machine_precision()> sigma;
real<lower=machine_precision()> epsilon;
}
transformed parameters {
vector[K] beta;
beta <- sigma * L * alpha;
}
model {
alpha ~ normal(0, 1);
y ~ normal(mu + beta, epsilon)
}
"
stan_cholesky <- stan_model(model_code = stan_cholesky)
stan_cholesky <- "
data {
int<lower=1> K; # outcomes
cov_matrix[K] Sigma;
vector[K] y;
}
transformed data {
matrix[K, K] L;
L <- cholesky_decompose(Sigma);
}
parameters {
real mu;
vector[K] alpha;
real<lower=machine_precision()> sigma;
real<lower=machine_precision()> epsilon;
}
transformed parameters {
vector[K] beta;
beta <- sigma * L * alpha;
}
model {
alpha ~ normal(0, 1);
y ~ normal(mu + beta, epsilon);
}
"
stan_cholesky <- stan_model(model_code = stan_cholesky)
load("~/Dropbox/GitHub/Adsp/data/mdata.rdt")
load("~/Dropbox/GitHub/Adsp/data/kinship.rdt")
head(mdata)
Sigma <- kinship$autosome
Sigma[Sigma < 0] <- 0
dat <- list(K = 576, Sigma = Sigma, y = mdata$AD1)
(fit_cholesky <- sampling(stan_cholesky, chain = 2, data = dat)) # 130 sec each chain
fit <- sampling(stan_cholesky, chain = 2, data = dat, iter = 400, warmup = 200)
adsp = list(mdata = mdata, kinship = kinship)
setwd("~/Dropbox/Github/BDA")
save(adsp, file = "adsp.rdt")
load("adsp.rdt")
Sigma <- adsp$kinship$autosome
Sigma[Sigma < 0] <- 0
dat <- list(K = 576, Sigma = Sigma, y = adsp$mdata$AD1)
fit <- sampling(stan_cholesky, chain = 2, data = dat, iter = 400, warmup = 200)
rm(list = ls())
stan_code <- "
data {
int<lower=0> N;
real y[N];
real mu_prior;
}
parameters {
real mu;
real<lower=machine_precision()> sigma;
}
model {
mu ~ normal(mu_prior, 1);
y ~ normal(mu, sigma);
}
generated quantities {
real lpd;
lpd <- normal_log(y, mu, sigma);
}
"
dat <- list(N = 10, y = rnorm(10, 1, 1), mu_prior = 2)
model <- stan_model(model_code = stan_code) # compilation
myfit <- sampling(model, data = dat) # fit by sampling
print(myfit)
myfit <- sampling(model, data = dat) # fit by sampling
print(myfit)
y
dat
hist(dat$y)
dat <- list(N = 10, y = rnorm(10, 1, 1), mu_prior = 2)
hist(dat$y)
myfit <- sampling(model, data = dat) # fit by sampling
print(myfit)
fit <- sampling(model, data = dat) # fit by sampling
print(myfit)
fit <- sampling(model, data = dat) # fit by sampling
print(myfit)
fit <- sampling(model, data = dat) # fit by sampling
print(myfit)
fit <- sampling(model, data = dat) # fit by sampling
print(myfit)
fit <- sampling(model, data = dat) # fit by sampling
print(myfit)
print(fit)
fit <- sampling(model, data = dat) # fit by sampling
print(fit)
fit <- sampling(model, data = dat) # fit by sampling
print(fit)
fit <- sampling(model, data = dat) # fit by sampling
print(fit)
fit <- sampling(model, data = dat) # fit by sampling
print(fit)
dat <- list(N = 10, y = rnorm(10, 1, 1), mu_prior = 10)
fit <- sampling(model, data = dat) # fit by sampling
print(fit)
dat <- list(N = 10, y = rnorm(10, 1, 1), mu_prior = 5)
fit <- sampling(model, data = dat) # fit by sampling
print(fit)
dat <- list(N = 10, y = rnorm(10, 1, 1), mu_prior = 1)
fit <- sampling(model, data = dat) # fit by sampling
print(fit)
dat <- list(N = 10, y = rnorm(10, 1, 1), mu_prior = 2)
fit <- sampling(model, data = dat) # fit by sampling
print(fit)
dat <- list(N = 10, y = rnorm(10, 1, 1), mu_prior = 1)
fit <- sampling(model, data = dat) # fit by sampling
print(fit)
dat <- list(N = 10, y = rnorm(10, 1, 1), mu_prior = 1)
fit <- sampling(model, data = dat) # fit by sampling
print(fit)
dat <- list(N = 10, y = rnorm(10, 1, 1), mu_prior = 2)
fit <- sampling(model, data = dat) # fit by sampling
print(fit)
dat <- list(N = 10, y = rnorm(10, 1, 1), mu_prior = 5)
fit <- sampling(model, data = dat) # fit by sampling
print(fit)
dat <- list(N = 10, y = rnorm(10, 1, 1), mu_prior = 5)
fit <- sampling(model, data = dat) # fit by sampling
print(fit)
dat <- list(N = 10, y = rnorm(10, 1, 1), mu_prior = 5)
fit <- sampling(model, data = dat) # fit by sampling
print(fit)
?optimizing
opt <- optimizing(model, data = dat)
opt
y = rnorm(10, 1, 1)
dat <- list(N = 10, y = y, mu_prior = 1)
(fit <- sampling(model, data = dat))
dat <- list(N = 10, y = y, mu_prior = 2)
(fit <- sampling(model, data = dat))
(fit <- sampling(model, data = dat))
(opt <- optimizing(model, data = dat))
(fit <- sampling(model, data = dat))
(fit <- sampling(model, data = dat))
dat <- list(N = 10, y = y, mu_prior = 5)
(fit <- sampling(model, data = dat))
(fit <- sampling(model, data = dat))
(fit <- sampling(model, data = dat))
dat <- list(N = 10, y = y, mu_prior = 5)
(fit <- sampling(model, data = dat))
a <- 0 # intercept
b <- 5 # slope
d <- 5 # standard deviation
n <- 31 # sample number
a <- 0 # intercept
b <- 5 # slope
d <- 5 # standard deviation
n <- 31 # sample number
x <- (-(n-1)/2):((n-1)/2) # independent x-values
y <-  a + b * x + rnorm(n = n, mean = 0, sd = d) # dependent values according to a + b*x + N(0,sd)
plot(x, y, main = "Test Data")
likelihood <- function(param) { # the black box
p1 = param[1]
p2 = param[2]
p3 = param[3]
prediction = p1 + p2*x
singlelikelihoods = dnorm(y, mean = prediction, sd = p3, log = T)
sumll = sum(singlelikelihoods)
return(sumll)
}
likelihood <- function(param) {
p1 = param[1]
p2 = param[2]
p3 = param[3]
prediction = p1 + p2*x
singlelikelihoods = dnorm(y, mean = prediction, sd = p3, log = T)
sumll = sum(singlelikelihoods)
return(sumll)
}
prior <- function(param){
p1 = param[1]
p2 = param[2]
p3 = param[3]
p1_prior = dnorm(p1, mean = 0, sd = 5, log = T)
p2_prior = dunif(p2, min = 0, max = 10, log = T)
p3_prior = dunif(p3, min = 0, max = 10, log = T)
return(p1_prior + p2_prior + p3_prior)
}
posterior <- function(param){
return (likelihood(param) + prior(param))
}
run_metropolis_MCMC <- function(startvalue, iterations){
chain = array(dim = c(iterations+1, 3))
chain[1,] = startvalue
for (i in 1:iterations){
proposal = rnorm(3, mean = chain[i,], sd = c(0.5,0.1,0.3))
probab = exp(posterior(proposal) - posterior(chain[i,]))
if (runif(1) < probab) {
chain[i+1,] = proposal
} else {
chain[i+1,] = chain[i,]
}
}
return(chain)
}
startvalue = c(0, 5, 10)
chain = run_metropolis_MCMC(startvalue, 1e4)
burnIn = 5e3
acceptance = 1-mean(duplicated(chain[-(1:burnIn),]))
par(mfrow = c(3,1))
hist(chain[-(1:burnIn), 1], main="Posterior of a", xlab="True value = red line" )
abline(v = mean(chain[-(1:burnIn), 1]))
abline(v = a, col="red" )
hist(chain[-(1:burnIn), 2], main="Posterior of b", xlab="True value = red line")
abline(v = mean(chain[-(1:burnIn), 2]))
abline(v = b, col="red" )
hist(chain[-(1:burnIn), 3], main="Posterior of sd", xlab="True value = red line")
abline(v = mean(chain[-(1:burnIn), 3]) )
abline(v = d, col="red" )
